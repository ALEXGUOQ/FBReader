This is a quick hack-and-slash port of HP STL to the Palm OS PRC-Tools.
Its only qualification is that it seems to build, and it is possible to
instantiate a vector<int> and call sort() on it. I did no other testing on
it. This is free software, so if it breaks, you get to keep both halves.
Do not send me tech support email or bug reports.

The original source code, from which this version is derived, can be got
from:

	ftp://ftp.cs.rpi.edu/pub/stl/hp/stl.zip

This version is missing some of the documentation from that package.

Warren Young <wdyoung@acm.org>, maintainer of the Palm Programmer's FAQ:
	http://www.cyberport.com/~tangent/palm/faq/

--------------------------------------------------------------------------

The original read.me and readme.old files follow:

----------------------------- read.me ------------------------------------
NOTICE:

(1) STL is the container, iterator, algorithm part of the C++ standard 
    library, it is not the complete standard library. (I/O streams, strings,
    etc. are not included in this package.)

(2) Minor changes to the STL is expected during the completion of the standard.

(3) The allocator files (defalloc.h, faralloc.h, hugalloc.h, lngalloc.h and
    neralloc.h) in the package are sample files. They are not designed for
    any specific machine and compiler system. For example, the assumption that
    type size_t and type ptrdiff_t used in the default allocator are of the 
    same size, it is not true with Borland compiler. Each compiler vendor 
    has to supply their own allocators to support the machine models they
    deal with.


This release (dated October 31, 1995) has the following changes:

- add default constructor in pair
- add default constructors in pointer_to_unary_function and 
  pointer_to_binary_function
- fix bugs in partial_sort and partial_sort_copy
- fix list sorting algorithm (a performance bug)
- fix bugs in specialized memory handling algorithms 
- fix a bug in distance
- fix a boundary condition bug in deque
- fix bugs in stable_sort and inplace_merge by rewriting the algorithms
- change iterator requirement for algorithms adjacent_find, min_element,
  and max_element
- make  __random_generator rd static
- change operators !=, >, <=, >= with one type parameter T to two type 
  parameters T1 and T2

Besides a number of fixes in the document, two major changes are
- revise the input iterator requirements
- remove raw_storage_iterator(11.2.3) and specialized algorithms (12.2)
  sections from the document (They were placed in the document when we 
  wanted to reveal some of the implementation details to the public before 
  we were able to release the STL code. They really do not belong to a 
  standard library specification.)

The postscript files of the document doc.ps and docbar.ps (with change bars
from the previous version) should print on both US letter and A4 page sizes.

The code difference from the previous version (July 7, 1995) is in file
files.dif.

-------------------------- readme.old ------------------------------------

The present implementation reflects the version of the STL document
dated: August 18, 1994.

It has many minor differences from the previous versions. The most
significant are:

	- inclusion of reference types in the allocators and containers;
	- inclusion of the reverse iterator type and rbegin(), rend()
	  functions in the containers;
	- inclusion of swap function in the containers;
	- elimination of empty and restrictor throughout.

To illustrate how to use allocators, several types of allocators and
containers using them are included.

The new version of STL has been compiled on:

Borland 4.0
EDG
IBM xlC
IBM C set

It would take an effort to port this code to a cfront based
compilers (e.g. HP). We have no experience with G++. 

There are some cases on which any of these compilers do not compile STL
code, but it is usually corner cases. Moreover, on Borland, for
example, STL does not compile the same cases on which Borland's own
library does not compile. 

We did not have time to put the ifdefs that will work around different
compiler bugs. The code is "generic" with only some workarounds for
the Borland compiler in it.

Users of Borland need to either comment out the definitions of min and
max in algobase.h or comment out Borland's min and max in stdlib.h.

You might encounter the following compiler problems:

1. functions that take const T & as an argument do not match arguments
of type T&. (Happens with max and min, for example.) The error
messages on Borland say "Illegal structure operation in ...". Three
possible workarounds are:
	- replacing const T& with T&;
	- replacing const T& with T;
	- providing a manual instantiation of an offending function.

2. Compiler matches templates incorrectly. That happens often if
different memory models are used together. copy, for example, is
instantiated for int* and then the same instance is used for copy(int
__huge *, ...). This bug is very hard to catch, because it is only run
time detectable. (Occasionally it might be indicated with a warning:
"Suspicious pointer conversion".) 

3. destroy does not work for your built-in type. (Most compilers have
a variant of this one.) As a workaround, provide your own destroy for
the type. (We include many of them in defalloc.h)


The only non-implemented parts of the STL as described in the document
are:

1) Constructor templates and insert templates for containers taking
two arbitrary iterators. They are simulated by a constructors taking
pointers.

2) Parameterization of containers with a template allocator is
simulated with the help of cpp.

3) Since bool is not yet implemented as a type on most compilers -
vector<bool> is impemented as bit_vector.

4) Default template arguments have to be always explicitly given.

The total amount of code that would need to be re-written when the
corresponding features are supported is of the order of 20 lines.


We intend to keep improving the implementation.  Therefore, we would
appreciate your comments and algorithmic bug reports.  Please send them
to:

stepanov@mti.sgi.com

or to:

lee@hpl.hp. com

or to:

musser@cs.rpi.edu

Please do not send us reports of compiler bugs.  Report them to your
compiler vendors.

The following files are included:

algo.h - includes all the algorithms
algobase.h - auxiliary file
bool.h - simulates bool
bvector.h - bit_vector
defalloc.h - allocator
deque.h - deque
doc.bar.ps - postscript of the document with change bars from the previous 
	version of the document
doc.ps - postscript of the document
doc.mif - framemaker's Maker Interchange Format of the document
faralloc.h - far_allocator 
fdeque.h - far_deque
flist.h - far_list
fmap.h - far_map
fmultmap.h - far_multimap
fmultset.h - far_multiset
fset.h - far_set
function.h - operators, function objects and function adaptors
hdeque.h - huge_deque
heap.h - auxiliary file
hlist.h - huge_list
hmap.h - huge_map
hmultmap.h - huge_multimap
hmultset.h - huge_multiset
hset.h - huge_set
hugalloc.h - huge_allocator
hvector.h - huge_vector
iterator.h - iterator tags, stream iterators and iterator adaptors
lbvector.h - long_bit_vector
ldeque.h - long_deque
list.h - list
llist.h - long_list
lmap.h - long_map
lmultmap.h - long_multimap
lmultset.h - long_multiset
lngalloc.h - long_allocator
lset.h - long_set
map.h - map
multimap.h - multimap
multiset.h - multiset
neralloc.h - near_allocator
nmap.h - near_map
nmultmap.h - near_multimap
nmultset.h - near_multiset
nset.h - near_set
pair.h - pair
projectn.h - auxiliary file
random.cpp - random number generator. It should be compiled and 
	linked if random_shuffle is used.
set.h - set
stack.h - container adaptors
tempbuf.cpp - an auxiliary buffer for get_temporary_buffer; it should be 
	compiled and linked if get_temporary_buffer, stable_partition,
	inplace_merge or stable_sort are used.
tempbuf.h - get_temporary_buffer
tree.h - auxiliary file
vector.h - vector
